-----------------------------------------------------------------------------
ROADMAP

0.1.0: (Spawn, 11/09)
	+ #328, x0: solid configuration system
	- #329, x0: response stream filter chain API (required for plugins: ssl, deflate, ssi, ...)
	- #324, x0: finish server limit configurations (keep-alive!)
	- x0: complete core API documentation
	- x0d: add settings option to setup process' cpu affinity
	- x0: ability to attach custom shared_ptr<>'d data to fileinfo record which is though released when its underlying inode changes.
	  this way i could speed up repeative directory listing generation
	  std::string data;
	  if (!my_fileinfo->get<std::string>(this, data))
	  {
		  // not cached yet -> create data and cache for subsequent calls
		  data = create_data();
	      my_fileinfo->set(this, data);
	  }
0.2.0: (Takeshi, 12/09)
	- #313, proxy plugin
		- must at least support backend: http
		- must support realtime streaming (required for YaCS chat stream to be passed through)
		- must support fallback (hot-spare) nodes
		- must support load-balancing across multiple backend nodes
	- #308, ssl plugin
		- must use gnutls via native api
		- must support server side certificates as passed via file (standard, just like apache etc)
	- dirlisting plugin
		- must support content template engine
0.3.0: (Squeezy, 01/10)
	- #307, deflate plugin
		- must support dynamic content compression
	- status plugin
		- must give some statistical/informational data about the running service
			- uptime
			- cpu load
			- current number of connections and their states
			- ...
0.4.0: (Sifu, 02/10)
	- #295, fastcgi plugin
	- #332, csp plugin (C++ server pages)

0.5.0: (Sensei, 05/10)
	- #331, webdav plugin
	- ssi plugin

-----------------------------------------------------------------------------
INTERMEDIATE TODO

for a long-term todo list, see ticket system at http://code.ninchens.net/projects/x0

- util:
	- new settings API
		1.) port TSettings to x0: `settings`
			datatypes supported: int, double, string, bool, map<K, V>, vector<V>
		2.) develop a settings visitor who imports the settings into the context scheme to at least match server-/vhosts contexts
	- chain API (or just a std::deque/std::list?)
		- filter chain API using the above/chain API
- core:
	- rfc_date-cache (Last-Modified, Date) i can't do simple caching of last active unix-time as the 
	  last-modified field shards this, i should use a cache<time_t, std::string> of configurable max-cost value.
	- async/parralel content generator handlers
	- handle request headers Keep-Alive properly (using asio [deadline-]timers)
	- make composite_buffer move constructable/assignable-only, that is, also remove copy constructor/assignment operator
- dirlisting:
	- themable index page via the lua-driven template engine i wrote for YaCS.
	  (maybe use this then also for an error plugin which generates themable error pages)
- docs:
	- bring API docs up-to-date.
- modules:
	- proxy (http), required to replace apache on ninchens.net server
		- must support live streams (required for YaCS chat stream)
		- must support fallback nodes (required for YaCS/maintenance)
	- ssl (via gnutls!), required for ninchens.net server
	- fastcgi

-----------------------------------------------------------------------------
NOTES AND THOUGHTS:
- should the upcoming (lua driven) template engine be part of x0 core?
  (we'll have more sources than just error documents being generated from templates, that is plugins like: dirlisting.
- cgi plugin:
  - find a way to get notified on SIGCHLD which should be caught in asio's io_service on EINTR's.
    hm. or just use sigaction/etc...? but what if other plugins may want to hook into SIGCHLD aswell?
	that's why we need a central place where we can register our check callback for it.
- sendfile plugin:
  - rename to "localfile", as it served local files, 
    though, leaving room for other plugins to serve static files aswell, but from a different storage source.
- ssl plugin:
  - idea 1: will need to hook into connection reader/writer.
    for the latter, it will need to provide its own composite_buffer writer atop of the standard socket writer
  - idea 2: idea: the connection class should provide read/write methods, and we'll provide a connection writer for composite_buffer instead.
    though, the ssl plugin (and deflate, e.g.) will just need to override the reader/writer for this connection.
  - idea 3: the ssl plugin hooks into the listener's accept() and creates an ssl aware socket, however, this REQUIRES
    all sockets (plain and ssl) to know about sendfile/writev for composite_buffer then).

-----------------------------------------------------------------------------
OPTIMIZATION AND CACHING INITIATIVE

- core optimizations:
  - server time (server::now()) should *NOT* be updated on every request handling.
    instead, only on each poll result.
	This maybe implies for us not to use the standard io_service::run()
	but something like that and call server time update right after each poll().
	MAYBE this can be also implemented directly (w/o hacking io_service::run) by
	calling something like post() on each update. hmmm.
  - optimize composite_buffer appending by merging nearby iovec chunks,
      if the left back and the right front is an iovec_chunk, and
      if the sum of both iovec elements does not exceed the system's iovec limit to writev(2)
- improve configuration system
	- dir contexts hierarichally via ternary_search<>

-----------------------------------------------------------------------------
bool chat_listener::handle_request(request& in, response& out)
{
	this->request = &in;
	this->response = &out;

	out.header("Content-Type", "text/html; charset=utf-8");

	out.write(chatStreamHead());

	out.incomplete(true);// explicit flush indicates that there *MIGHT* be more to come, but we flush what we have.
	out.flush(); 

	return true;
}

void channel::say(const message& msg)
{
	for (auto i = members.begin(), e = members.end(); i != e; ++i)
	{
		auto member = *i;
		member->write(message);
	}
}
void member::write(const message& msg) {
	listener->response->write(msg.text());
	listener->response->flush();
}
void ChatSession::~ChatSession() {
	listener->response->finish();
}

response::finish() {
	flush();
}
response::flush() {
	ios.post(do_flush());
}
response::do_flush() {
	// write remaining data.
}
