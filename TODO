for a long-term todo list, see ticket system at http://redmine.xzero.ws/projects/x0

-----------------------------------------------------------------------------
QUALITY ASSURANCE TODO:
-----------------------------------------------------------------------------
- VALGRIND: fix warnings about buffer_ref::find() -- there was code around already fixing that issue
- VALGRIND: fix warnings wrt libev's ev_stat (ev.c:3119), ev_stat.attr seems uninitialized, as of valgrind.
- FIX: SIGTERM gets catched but does not lead into process termination (event-loop does not break?)
- IMPROVE: SSL-handshake performance, should not take up to 2.5 seconds on my netbook.
- IMPROVE: chunked-encoding should NOT be triggered if no response content body is allowed (e.g. 400)
- VERIFY: flexibility of configuratio nsystem
	- plugins/core should provide an abstract layer to the config backend, in a way, that they do not need
		to qualify the complete path to the variable but just say ConfigKey and ideally $CONTEXT (global, vhost, path);
	- scopes:
		- global server context
		- per virtual host
		- per request path prefix
	- runtime changing of config settings
- RESPECT: handle request headers Keep-Alive properly (using [deadline-]timers)
- rfc_date-cache (Last-Modified, Date) i can't do simple caching of last active unix-time as the 
  last-modified field shards this, i should use a cache<time_t, std::string> of configurable max-cost value.
  (NOTE: why did I say that? why does mtime shard the server's "Date:"?)


-----------------------------------------------------------------------------
CODE CLEANUP TODO:
-----------------------------------------------------------------------------
- port cgi plugin to current API changes!
	- make use of response_parser
- process: termination handler, some kind of hook that is invoked when the application is terminated (with whatever signal or not).
	- make use of libev's child watcher
- plugins/cgi: pass completion handler to cgi_script::async_run(...)
- file -> filereader; fileinfo -> file; fileinfo_service -> file_service
- proper HTTP POST reader API: as part of request class
	- should consume the body automatically if not read by a handler until response headers are flushed
	- buffer_ref body_read(buffer& output);
	- std::size_t body_available() const; // number of bytes still in stream to read until fully *consumed*
	- bool consume(); // true=fully consumed, false=partially consumed
	- bool on_body_read(CompletionHandler handler); // registers callback when more *body* data is available for read
- generalize request_parser just like done with response_parser
- reduce number of syscalls during a single request-processing


-----------------------------------------------------------------------------
FEATURES TODO:
-----------------------------------------------------------------------------
- x0d: add settings option to setup process' cpu affinity
- proper protocol "Upgrade"-API, as required for web sockets
- connection: add read/write hooks, as required for the upcoming ssl plugin. these functors do standard I/O if not overridden.
	int read(buf, nbytes);
	int read(buf, nbytes);
- add integrity-checks for lazy programmers to check object healthy:
	- If response Content-Length was given: do not write more bytes than expected to.
	- Do not modify response headers/state once serialization has been initiated.
- add response::bytes_transferred (unsigned), which is updated automatically by write() (or something deeper) to
  match the bytes written to the client.
  This is required by the accesslog plugin to log the number of bytes sent (which is not actually content-length, or is it?)
- debug plugin: config settings for different debug prints
	- per connection performance timer
	- per request performance timer
	- request/response header dumps
- request path rewriting (rewrite)
- http reverse proxy (plugin)
	- must support live streams (required for YaCS chat stream)
	- must support fallback nodes (required for YaCS/maintenance)
- server status API (status)
- fastcgi support (fastcgi)
- lua server pages (wsapi)
- c++ server pages (csp)
- webdav support (webdav)


-----------------------------------------------------------------------------
ROADMAP
-----------------------------------------------------------------------------
*0.1.0: (02/10)*
	- x0: complete core API documentation
*0.2.0: (03/10)*
	- reverse proxy plugin
		- must at least support backend: http
		- must support realtime streaming (required for YaCS chat stream to be passed through)
		- must support fallback (hot-spare) nodes
		- must support load-balancing across multiple backend nodes
	- dirlisting plugin
		- themable index page via the lua-driven template engine i wrote for YaCS.
		  (maybe use this then also for an error plugin which generates themable error pages)
*0.3.0: (06/10)*
	- status plugin
		- must give some statistical/informational data about the running service
			- uptime
			- cpu load
			- current number of connections and their states
			- ...
*0.4.0: (09/10)*
	- fastcgi plugin
	- csp plugin (C++ server pages)

*0.5.0: (12/10)*
	- webdav plugin
	- ssi plugin?


-----------------------------------------------------------------------------
NOTES AND THOUGHTS:
-----------------------------------------------------------------------------

- should the upcoming (lua driven) template engine be part of x0 core?
  (we'll have more sources than just error documents being generated from templates, that is plugins like: dirlisting.
- evaluate the use of signalfd(2) with regards to cgi plugin (for watching child process termination) and possibly others
- cgi plugin:
  - find a way to get notified on SIGCHLD which should be caught in asio's io_service on EINTR's.
    hm. or just use sigaction/etc...? but what if other plugins may want to hook into SIGCHLD aswell?
	that's why we need a central place where we can register our check callback for it.
- sendfile plugin:
  - rename to "localfile", as it served local files, 
    though, leaving room for other plugins to serve static files aswell, but from a different storage source.
- ssl plugin:
  - idea 1: will need to hook into connection reader/writer.
    for the latter, it will need to provide its own composite_buffer writer atop of the standard socket writer
  - idea 2: idea: the connection class should provide read/write methods, and we'll provide a connection writer for composite_buffer instead.
    though, the ssl plugin (and deflate, e.g.) will just need to override the reader/writer for this connection.
  - idea 3: the ssl plugin hooks into the listener's accept() and creates an ssl aware socket, however, this REQUIRES
    all sockets (plain and ssl) to know about sendfile/writev for composite_buffer then).


-----------------------------------------------------------------------------
OPTIMIZATION AND CACHING INITIATIVE
-----------------------------------------------------------------------------

- core optimizations:
	- ...
- improve configuration system
	- dir contexts hierarichally via ternary_search<>


